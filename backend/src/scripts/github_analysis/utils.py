import os, hashlib, logging, pathlib, re

# ---------- file filters ----------
# More comprehensive code file extensions
CODE_EXTS = {
    # General programming languages
    '.py', '.java', '.js', '.ts', '.cpp', '.cc', '.c', '.h', '.hpp',
    # Web development
    '.php', '.php3', '.php4', '.php5', '.php7', '.phtml', '.rb', '.go', '.cs', '.scala',
    '.html', '.htm',  '.scss', '.sass', '.less', '.vue', '.svelte',
    # Mobile development
    '.dart', '.kt', '.swift', '.m', '.mm',
    # Template files
    '.ejs', '.hbs', '.mustache', '.pug', '.jade', '.twig',
    # Shell scripts
    '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.cmd'
}

# Expanded list of directories to skip
SKIP_DIRS = {
    # Build & dependency directories
    'node_modules', 'venv', '.venv', 'env', 'virtualenv', 'vendor',
    'bower_components', 'jspm_packages', 'packages', 'libs', 'external',
    # Build directories (expanded)
    'build', 'dist', 'out', 'output', 'bin', 'obj', 'target', 'release', 'debug',
    # Cache & compiled code
    '__pycache__', '.dart_tool', '.next', '.nuxt', '.output', '.parcel-cache',
    '.gradle', '.nuget', '.pub-cache', '.cache', '.npm', 'assets/cache',
    # Development tools & metadata
    '.git', '.github', '.gitlab', '.svn', '.idea', '.vscode', '.vs',
    '.project', '.settings', '.metadata', '.sass-cache', '.storybook',
    # Generated docs
    'coverage', 'docs', 'doc', 'apidoc', 'javadoc', 'site-packages',
    # Temporary & logging
    'tmp', 'temp', 'logs', 'log', 'cache', 'artifacts'
}

# Files to skip (often large or irrelevant files)
SKIP_FILES = {
    # Minified files & bundles
    'min.js', 'bundle.js', 'vendor.js', 'polyfill.js', 'runtime.js', 'chunk.js',
    # Lock files & package specs
    'package-lock.json', 'yarn.lock', 'Pipfile.lock', 'poetry.lock', 'pnpm-lock.yaml',
    'requirements.txt', 'pyproject.toml', 'setup.py', 'Cargo.toml', 'Cargo.lock',
    # Large generated files
    'schema.json', 'schema.graphql', 'translations.json', 'i18n.json', 'locales.json',
    # Build scripts
    'webpack.config.js', 'rollup.config.js', 'gulpfile.js', 'gruntfile.js', 'makefile', 'Makefile',
    # Config files
    '.babelrc', '.eslintrc', '.prettierrc', 'tsconfig.json', '.editorconfig', '.browserslistrc',
    # Test files
    'test.js', 'spec.js', 'test.py', 'spec.py', 'test.java', 'spec.java'
}

# Expanded build-related path patterns to skip
BUILD_PATTERNS = [
    '/build/', '\\build\\', '/dist/', '\\dist\\', 
    '/bin/', '\\bin\\', '/obj/', '\\obj\\',
    '/target/', '\\target\\', '/out/', '\\out\\',
    'generated', 'auto-generated', 'autogenerated',
    '/tests/', '\\tests\\', '/test/', '\\test\\',
    '/mock/', '\\mock\\', '/mocks/', '\\mocks\\',
    '/example/', '\\example\\', '/examples/', '\\examples\\'
]

# Build-related function name patterns to skip
BUILD_FUNCTION_PATTERNS = [
    r'^build[A-Z]', r'setup[A-Z]', r'configure[A-Z]',
    r'init[A-Z]', r'generate[A-Z]', r'create[A-Z]Builder',
    r'make[A-Z]', r'compile[A-Z]', r'process[A-Z]',
    r'test[A-Z]', r'^test_', r'^_test', r'assert[A-Z]'
]

def is_code_file(fp):
    """Determine if a file is source code and not a build/generated file."""
    # Get file extension
    ext = os.path.splitext(fp)[1].lower()
    filename = os.path.basename(fp).lower()
    filepath = fp.replace('\\', '/')
    
    # Skip binary file formats
    binary_ext = ['.pyc', '.so', '.dll', '.exe', '.obj', '.png', '.jpg', '.jpeg', '.gif', '.pdf', '.zip', '.tar', 
                  '.gz', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.jar', '.apk', '.ipa', '.aab',
                  '.woff', '.woff2', '.ttf', '.otf', '.eot', '.ico', '.svg', '.mp3', '.mp4', '.mov', '.avi']
    if ext in binary_ext:
        return False
    
    # Skip build-related paths
    for pattern in BUILD_PATTERNS:
        if pattern in filepath:
            return False
    
    # Skip directories to exclude
    parts = filepath.split('/')
    for part in parts:
        if part in SKIP_DIRS:
            return False
    
    # Skip specific files to exclude
    for skip_file in SKIP_FILES:
        if filename.endswith(skip_file) or filename == skip_file:
            return False
    
    # Skip dot-files and dot-directories (except common config files)
    for p in parts:
        if p.startswith('.') and p != '.' and p != '..' and not p.endswith(('.json', '.js', '.ts', '.py', '.yml', '.yaml')):
            return False
    
    # Check if the file is a known code file type
    if ext not in CODE_EXTS:
        # Log files that don't have supported extractors but are still code files
        if ext in CODE_EXTS and ext not in ['.py', '.java', '.js', '.jsx', '.ts', '.tsx', '.dart', '.php', '.php3', '.php4', '.php5', '.php7', '.phtml']:
            logging.info(f"INFO: Skipping known code file without extractor: {fp} (ext: {ext})")
        return False
    
    # Skip overly large files (likely generated code)
    try:
        size = os.path.getsize(fp)
        if size > 500 * 1024:  # Skip files larger than 500KB
            logging.info(f"INFO: Skipping large file (likely generated): {fp} ({size/1024:.1f}KB)")
            return False
    except Exception:
        pass
    
    return True

def is_build_function(function_name):
    """Determine if a function appears to be build-related."""
    function_name = function_name.strip()
    if not function_name:
        return False
    
    # Check against build-related function patterns
    for pattern in BUILD_FUNCTION_PATTERNS:
        if re.match(pattern, function_name):
            return True
    
    # Keywords suggestive of build functions
    build_keywords = ['build', 'setup', 'config', 'init', 'generate', 'create', 
                     'make', 'compile', 'process', 'test', 'assert', 'mock']
    
    # Check if the function name starts with or contains these words
    for keyword in build_keywords:
        if function_name.lower().startswith(keyword) or f"_{keyword}" in function_name.lower():
            return True
    
    return False

# ---------- helpers ----------
def sha(text:str)->str:
    return hashlib.sha1(text.encode('utf-8')).hexdigest()

def safe_read(fp):
    try:
        with open(fp,'r',encoding='utf-8',errors='ignore') as f:
            return f.read()
    except Exception as e:
        logging.error(f"Read error {fp}: {e}")
        return ""

def find_balanced_brace(content:str,start:int)->int:
    depth,pos=1,start
    while pos<len(content) and depth:
        if content[pos]=='{': depth+=1
        elif content[pos]=='}': depth-=1
        pos+=1
    return pos if depth==0 else -1
